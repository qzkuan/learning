







## 抽象类与接口

### 抽象类



> 注：

- 抽象类中可以有零个或多个抽象方法，也可以包含非抽象的方法。·抽象类中可以没有抽象方法，但是，有抽象方法的类必须是抽象类。
- 如果父类中已有同名的abstract方法，则子类中就不能再有同名的抽象方法。
- abstract不能与final并列修饰同一个类。
- abstract 不能与private、static、final或native并列修饰同一个方法



接口就是一种特殊的abstract class，但是比abstract class更加抽象



### 抽象类和接口的对比

#### 相同之处

1. 接口就是一种特殊的abstract class，但是比abstract class更加抽象。
2. 都不能被实例化。
3. 接口的实现类和抽象类的子类只有全部实现了接口或者抽象类中的方法后才可以被实例化。

#### 不同之处



| **参数**           | **抽象类**                                                   | **接口**                                                     |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 默认的方法实现     | 可以有默认的方法实现                                         | 接口是完全抽象的，不存在方法的实现（JDK8可以）               |
| 实现               | 子类使用**extends**关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。 | 子类使用关键字**implements**来实现接口。它需要提供接口中所有声明的方法的实现 |
| 构造器             | 抽象类可以有构造器                                           | 接口不能有构造器                                             |
| 与正常Java类的区别 | 除了你不能实例化抽象类之外，它和普通Java类没有任何区别       | 接口是完全不同的类型                                         |
| 访问修饰符         | 抽象方法可以有**public**、**protected**和**default**这些修饰符，但是不能是**private**（无法被继承）<br />默认**default** | 接口方法默认修饰符是**public**。你不可以使用其它修饰符。<br />接口中的方法默认修饰符为“public abstract”<br />接口中所有的属性的修饰符都默认为"public static final" |
| main方法           | 抽象方法可以有main方法并且我们可以运行它                     | 接口没有main方法，因此我们不能运行它。（java8以后接口可以有default和static方法，所以可以运行main方法） |
| 多继承             | 抽象方法可以继承一个类和实现多个接口                         | 接口只可以继承一个或多个其它接口                             |
| 速度               | 它比接口速度要快                                             | 接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。   |
| 添加新方法         | 如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 | 如果你往接口中添加方法，那么你必须改变实现该接口的类。       |
| 设计方式           | 自下而上                                                     | 自上而下                                                     |



## Quartz



### 时间设置

```java
每天凌晨2点  0 0 2 * * ?
每天隔一小时 0 * */1 * * ?

例1：每隔5秒执行一次：*/5 * * * * ?

例2：每隔5分执行一次：0 */5 * * * ?
在26分、29分、33分执行一次：0 26,29,33 * * * ?

例3：每天半夜12点30分执行一次：0 30 0 * * ? （注意日期域为0不是24）
每天凌晨1点执行一次：0 0 1 * * ?

每天上午10：15执行一次： 0 15 10 ? * * 或 0 15 10 * * ? 或 0 15 10 * * ? *

每天中午十二点执行一次：0 0 12 * * ?

每天14点到14：59分，每1分钟执行一次：0 * 14 * * ?

每天14点到14：05分，每1分钟执行一次：0 0-5 14 * * ?

每天14点到14：55分，每5分钟执行一次：0 0/5 14 * * ?

每天14点到14：55分，和18点到18点55分，每5分钟执行一次：0 0/5 14,18 * * ?

每天18点执行一次：0 0 18 * * ?

每天18点、22点执行一次：0 0 18,22 * * ?

每天7点到23点，每整点执行一次：0 0 7-23 * * ?

每个整点执行一次：0 0 0/1 * * ?

 
这些星号由左到右按顺序代表 ：     *    *     *     *    *     *   *    * 
                              格式： [秒] [分] [小时] [日] [月] [周] [年] 
序号 说明 
  是否必填  允许填写的值 允许的通配符 
 秒  是  0-59    , - * / 
 分  是  0-59 
   , - * / 
小时  是  0-23   , - * / 
 日  是  1-31   , - * ? / L W 
 月  是  1-12 or JAN-DEC   , - * / 
 周  是  1-7 or SUN-SAT   , - * ? / L # 
 年  否  empty 或 1970-2099  , - * / 
通配符说明: 
* 表示所有值. 例如:在分的字段上设置 "*",表示每一分钟都会触发。 
? 表示不指定值。使用的场景为不需要关心当前设置这个字段的值。例如:要在每月的10号触发一个操作，但不关心是周几，所以需要周位置的那个字段设置为"?" 具体设置为 0 0 0 10 * ? 
- 表示区间。例如 在小时上设置 "10-12",表示 10,11,12点都会触发。 
, 表示指定多个值，例如在周字段上设置 "MON,WED,FRI" 表示周一，周三和周五触发 
/ 用于递增触发。如在秒上面设置"5/15" 表示从5秒开始，每增15秒触发(5,20,35,50)。在月字段上设置'1/3'所示每月1号开始，每隔三天触发一次。 
L 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会依据是否是润年[leap]), 在周字段上表示星期六，相当于"7"或"SAT"。如果在"L"前加上数字，则表示该数据的最后一个。例如在周字段上设置"6L"这样的格式,则表示“本月最后一个星期五" 
W 表示离指定日期的最近那个工作日(周一至周五). 例如在日字段上设置"15W"，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发.如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 "1W",它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，"W"前只能设置具体的数字,不允许区间"-"). 
小提示 
'L'和 'W'可以一组合使用。如果在日字段上设置"LW",则表示在本月的最后一个工作日触发(一般指发工资 ) 
# 序号(表示每月的第几个周几)，例如在周字段上设置"6#3"表示在每月的第三个周六.注意如果指定"#5",正好第五周没有周六，则不会触发该配置(用在母亲节和父亲节再合适不过了) 
小提示 
周字段的设置，若使用英文字母是不区分大小写的 MON 与mon相同. 
常用示例: 
0 12 * * ? 每天12点触发 
15 10 ? * * 每天10点15分触发 
15 10 * * ? 每天10点15分触发 
15 10 * * ? * 每天10点15分触发 
15 10 * * ? 2005 2005年每天10点15分触发 
* 14 * * ? 每天下午的 2点到2点59分每分触发 
0/5 14 * * ? 每天下午的 2点到2点59分(整点开始，每隔5分触发) 
0/5 14,18 * * ? 每天下午的 2点到2点59分(整点开始，每隔5分触发) 
每天下午的 18点到18点59分(整点开始，每隔5分触发) 
0-5 14 * * ? 每天下午的 2点到2点05分每分触发 
10,44 14 ? 3 WED     3月分每周三下午的 2点10分和2点44分触发 （特殊情况，在一个时间设置里，执行两次或 两次以上的情况） 
59 2 ? * FRI    每周5凌晨2点59分触发； 
15 10 ? * MON-FRI 从周一到周五每天上午的10点15分触发 
15 10 15 * ? 每月15号上午10点15分触发 
15 10 L * ? 每月最后一天的10点15分触发 
15 10 ? * 6L 每月最后一周的星期五的10点15分触发 
15 10 ? * 6L 2002-2005 从2002年到2005年每月最后一周的星期五的10点15分触发 
15 10 ? * 6#3 每月的第三周的星期五开始触发 
0 12 1/5 * ? 每月的第一个中午开始每隔5天触发一次 
11 11 11 11 ? 每年的11月11号 11点11分触发(光棍节)
```



## IO

> I/O，即输入（Input）/ 输出（Output），IO流指的是数据像连绵的流体一样进行传输。

###  IO流的分类

按数据的**流向**分为：输入流和输出流

按数据的**类型**分为：
 字节流：以字节为单位来操作数据。
  InputStream: 字节输入流的顶层抽象类.
   FileInputStream:普通的字节输入流.
   BufferedInputStream: 高效的字节输入流(也叫: 字节缓冲输入流)
  OutputStream:字节输出流的顶层抽象类.
   FileOutputStream:普通的字节输出流.
   BufferedOutputStream:高效的字节输出流(也叫: 字节缓冲输出流).
 字符流: 以字符为单位来操作数据
  Reader: 字符输入流的顶层抽象类.
   FileReader:普通的字符输入流.
   BufferedReader:高效的字符输入流(也叫: 字符缓冲输入流)
  Writer: 字符输出流的顶层抽象类.
   FileWriter:普通的字符输出流.
   BufferedWriter:高效的字符输出流(也叫: 字符缓冲输出流)

```java
package com.example.learn.io;

import org.junit.Test;
import java.io.*;

/**
 * @author qzkuan(qqaxxn @ 163.com)
 * @className CopyFile
 * @packageName com.example.learn.io
 * @date 2021-02-25 20:07
 * @description TODO
 */
public class CopyFile {
    // 【注】字符流，只能操作文本文件，不能操作图片，视频等非文本文件。当我们单纯读或者写文本文件时使用字符流其他情况使用字节流

    /**
     * 字节缓冲
     *
     * @throws IOException
     */
    @Test
    public void testStream() throws IOException {
        //记录开始时间
        long start = System.currentTimeMillis();
        //创建字节缓冲流对象
        BufferedInputStream bis = new BufferedInputStream(new FileInputStream("C:\\Users\\qzkuan\\Desktop\\vim.jpg"));
        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("C:\\Users\\qzkuan\\Desktop\\vim_stream.jpg"));
        int len;
        byte[] bytes = new byte[2048];
        while ((len = bis.read(bytes)) != -1) { //读数据
            //写数据
            bos.write(bytes, 0, len);
        }
        bis.close();
        bos.close();
        //记录结束时间
        long end = System.currentTimeMillis();
        System.out.println("缓冲流使用数组复制时间:" + (end - start) + " 毫秒");
    }

    /**
     * 字符缓冲
     * 特有方法BufferedReader：public String readLine()：读一行数据。 读取到最后返回null。
     * 特有方法BufferedWriter：public void newLine(): 换行,由系统属性定义符号。
     *
     * @throws IOException
     */
    @Test
    public void reader() throws IOException {
        //记录开始时间
        long start = System.currentTimeMillis();
        //1.创建字符缓冲输入流读文件对象
        BufferedReader br = new BufferedReader(new FileReader("C:\\Users\\qzkuan\\Desktop\\1.txt")); //读取png有问题。。
        //1.创建字符缓冲输出流读文件对象
        BufferedWriter bw = new BufferedWriter(new FileWriter("C:\\Users\\qzkuan\\Desktop\\1_reader.txt"));
        int len;
        char[] chars = new char[1024];
        while ((len = br.read(chars)) != -1) { //读数据
            //写数据
            bw.write(chars, 0, len);
        }
        br.close();
        bw.close();
        //记录结束时间
        long end = System.currentTimeMillis();
        System.out.println("缓冲流使用数组复制时间:" + (end - start) + " 毫秒");
    }
}


```





































































